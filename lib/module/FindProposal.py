#coding:utf-8
import torch as t
import six
import torch.nn.functional as F
import os
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from collections import Counter
from lib.core.visImage import tensor_to_PIL

os.environ["CUDA_VISIBLE_DEVICES"] = "1"


def FindProposal(model,init_img, n_grids=4):
    #model = model.cuda()
    #init_img = init_img.cuda()

    model.eval()
    C,H,W = init_img.shape
    assert H==W
    step = int(H / n_grids)
    num_grid = n_grids * n_grids
    grid_coord = np.zeros((num_grid,4))
    bagsofimg = []
    k = 0

    for yy in range(n_grids):  # yi
        for xx in range(n_grids):  # xi
            c = np.array([yy*step,xx*step,(yy+1)*step,(xx+1)*step])
            grid_coord[k,:] =c
            k +=1
            tmpimage = init_img.clone()
            #for ch in range(3):
            tmpimage[:,c[0]:c[2],c[1]:c[3]] = t.from_numpy(np.array(0.5))
            bagsofimg.append(tmpimage)
            #te = tmpimage.clone()
            #re = model(te.unsqueeze(0))
            #re = F.softmax(re, 1).squeeze()
            #_, ind = re.sort(0, True)
            #print("max i s {}".format(ind[0]))

            #imshow(tmpimage,str(xx)+str(yy))
    bagsofimg_ = t.stack(bagsofimg)# num grid  * c * h * w

    logit = model(bagsofimg_)

    logit_ = F.softmax(logit, 1).detach().squeeze()# num grid * num classes
    #print("第一次输出")
    #print(logit_)
    #torch.FloatTensor
    #torch.LongTensor
    prob, index = logit.sort(1, True)# 降序

    gridsprob_predict = logit_
    gridslabel_predict = index[:,0].squeeze().cpu()# num grid * 1
    #print("预测的label {}".format(gridslabel_predict))

    label_counts = Counter(gridslabel_predict)
    top_label = label_counts.most_common(5)
    print("predict label {}".format(top_label[0][0]))
    most_possibel_label = top_label[0][0]

    predict_prob_masked_img = gridsprob_predict[:,most_possibel_label].squeeze()# num grid 个masked 图都是应该属于 投票 票数最多的那类
    #print("每个mask的图片 属于target的概率是 {}".format(predict_prob_masked_img))
    _,index_ = predict_prob_masked_img.sort(0,False)#升序
    #print("原始坐标{}".format(grid_coord))
    loc_attention = grid_coord[index_[0].cpu().numpy(),:]
    print(loc_attention)
    ############################## 回归#########################################
    anchor = generate_anchor_base(loc_attention)
    #print("anchor is {}".format(anchor))
    num_box = anchor.shape[0]

    pltimg = tensor_to_PIL(init_img)
    im = np.array(pltimg,dtype=np.uint8)
    fig,ax = plt.subplots(1)
    ax.imshow(im)

    bagsofimg2 = []
    for ii in range(num_box):
        image = init_img.clone()

        image[:, int(anchor[ii][0]):int(anchor[ii][2]), int(anchor[ii][1]):int(anchor[ii][3])] = t.from_numpy(np.array(0.5))
        bagsofimg2.append(image)
        #(x,y) , w, h
        rect = patches.Rectangle((anchor[ii][1],anchor[ii][0]),anchor[ii][3]-anchor[ii][1],anchor[ii][2]-anchor[ii][0],linewidth=1,edgecolor='red',facecolor='none')
        ax.add_patch(rect)
    plt.show()
    bagsofimg2_ = t.stack(bagsofimg2)
    logit2 = model(bagsofimg2_)
    logit2_ = F.softmax(logit2, 1).detach().squeeze()
    prob2, index2 = logit.sort(1, True)# 降序
    index2_ = index2.cpu()



    countlabel = Counter(index2_[:,0].squeeze())
    top = countlabel.most_common(3)
    most_possibel_label2 = top[0][0]
    predict_prob_boxes = logit2_[:,most_possibel_label2].squeeze()# num of boxes 个概率
    #print("target probs is {}".format(prob_target))
    _,idx = predict_prob_boxes.sort(0,False)#升序
    #print("soted result {}".format(prob_target[indx]))
    target_box = anchor[idx[0]]# 同样的概率最小的最可能是  重要的区域
    #print("target box {}".format(target_box))

    return target_box


def generate_anchor_base(loc, base_size=10, ratios=[0.5,0.75,1,1.25,1.5],
                         anchor_scales=[2,4,6,8,10,12,15]):
    """Generate anchor base windows by enumerating aspect ratio and scales.

    Generate anchors that are scaled and modified to the given aspect ratios.
    Area of a scaled anchor is preserved when modifying to the given aspect
    ratio.

    :obj:`R = len(ratios) * len(anchor_scales)` anchors are generated by this
    function.
    The :obj:`i * len(anchor_scales) + j` th anchor corresponds to an anchor
    generated by :obj:`ratios[i]` and :obj:`anchor_scales[j]`.

    For example, if the scale is :math:`8` and the ratio is :math:`0.25`,
    the width and the height of the base window will be stretched by :math:`8`.
    For modifying the anchor to the given aspect ratio,
    the height is halved and the width is doubled.

    Args:
        base_size (number): The width and the height of the reference window.
        ratios (list of floats): This is ratios of width to height of
            the anchors.
        anchor_scales (list of numbers): This is areas of anchors.
            Those areas will be the product of the square of an element in
            :obj:`anchor_scales` and the original area of the reference
            window.

    Returns:
        ~numpy.ndarray:
        An array of shape :math:`(R, 4)`.
        Each element is a set of coordinates of a bounding box.
        The second axis corresponds to
        :math:`(y_{min}, x_{min}, y_{max}, x_{max})` of a bounding box.

    """
    py = int(loc[2]+loc[0]) / 2
    px = int(loc[3]+loc[1]) / 2

    anchor_base = np.zeros((len(ratios) * len(anchor_scales), 4),dtype=np.float32)
    for i in six.moves.range(len(ratios)):
        for j in six.moves.range(len(anchor_scales)):
            h = base_size * anchor_scales[j] * np.sqrt(ratios[i])
            w = base_size * anchor_scales[j] * np.sqrt(1. / ratios[i])

            index = i * len(anchor_scales) + j
            anchor_base[index, 0] = py - h / 2.
            anchor_base[index, 1] = px - w / 2.
            anchor_base[index, 2] = py + h / 2.
            anchor_base[index, 3] = px + w / 2.
            if anchor_base[index, 0]<0:anchor_base[index, 0]=0
            if anchor_base[index, 1]<0:anchor_base[index, 1]=0
            if anchor_base[index, 2]>223:anchor_base[index, 2]=223
            if anchor_base[index, 3]>223:anchor_base[index, 3]=223
    return anchor_base


if __name__ == '__main__':
    from PIL import Image
    import numpy as np

    image = Image.open('./cooking_015.jpg')

    plt.figure(num=5, figsize=(8, 5), )
    # plt.figure(num='newimage', figsize=(8,5),)
    plt.title('The image title', color='#0000FF')
    plt.imshow(image)  # 显示图片
    plt.axis('off')  # 不显示坐标轴
    plt.show()

    from torchvision import transforms as T

    trn = T.Compose([T.Resize((224, 224)),
                     T.ToTensor(),
                     T.Normalize([0.5, 0.5, 0.5, 0.5], [0.5, 0.5, 0.5, 0.5])])
    new_img = trn(image)

    box = FindProposal(new_img, 3)
    y1, x1, y2, x2 = box

    new_img = tensor_to_PIL(new_img)
    im = np.array(new_img, dtype=np.uint8)

    # Create figure and axes
    fig, ax = plt.subplots(1)

    # Display the image

    ax.imshow(im)

    # Create a Rectangle patch
    rect = patches.Rectangle((x1, y1), x2 - x1, y2 - y1, linewidth=1, edgecolor='r', facecolor='none')

    # Add the patch to the Axes
    ax.add_patch(rect)

    plt.show()

    print("result box is {} ".format(box))


